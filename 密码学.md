# 密码学

## 第1章 概论

### 1.1 密码学和现代密码学

尝试定义现代密码学：对安全地进行数字信息和事务处理、分布式计算所需技术的科学研究

### 1.2 对称密钥加密的基本设置

隐含着一个假设：通信方可以使用某种秘密的方式建立初始的共享密钥（注意，如果一方通过公共信道简单地发送密钥给另一方，窃听者将也能获得密钥）。

**对称加密方案由三个算法组成**：密钥产生，加密，解密。

1. 密钥产生算法 $Gen()$ 是一个概率算法，能够根据方案定义的某种分布选择并输出一个密钥 $k$。记为 $k = Gen()$，值域称为密钥空间用 $K$ 表示。
2. 加密算法 $Enc()$，输入为密钥 $k$ 和明文 $m$，输出为密文 $c$。记为 $c = Enc(m, k)$
3. 解密算法 $Dec()$，输入为密钥 $k$ 和密文 $c$，输出为明文 $m$。记为 $m = Dec(c, k)$

通常，$Gen()$ 简单地从密钥空间中均匀随机地选择一个密钥（事实上，这种假设不失一般性）。所有“合法”消息的集合记做 $M$，并称为明文空间。因为任何密文都是通过使用密钥加密明文来获得的，集合 $K$ 和 $M$ 一起定义了所有可能密文的集合 $C$。**一个加密方案可通过明确三个算法$（Gen，Enc，Dec）$和明文空间 $M$ 来完全定义**。

任意加密方案的基本要求：对于任意通过 $Gen()$ 输出的密钥 $k$，每个明文消息 $m\in M$，满足：
$$
Dec(Enc(m, k), k) = m
$$
**Kerckhoffs原则（开放的密码学设计原则）**：加密方案本身不需要保密，唯一需要保密的是通信双方共享的秘密密钥。

接受Kerckhoffs原则的三个主要理由：

1. 通信各方更容易维护短小密钥的保密性
2. 万一密钥暴露了，非常容易改变密钥而不是替换算法
3. 万一有多对人员需要加密他们的通信，对所有参与方而言，使用同样的算法不同的密钥，与使用不同的算法相比要容易得多

**攻击场景**

1. 唯密文攻击（Ciphertext-only attack）：这是最基本的攻击方式，表示敌手只能观察到密文（或者多个密文）,并且试图确定相应的明文（或者多个明文）。
2. 已知明文攻击（Known-plaintext attack）：这里，敌手学习一个或者多个使用相同密钥加密的明文/密文对。目标是确定其他密文对应的明文（这里“其他”是指事先不知道明文的密文）。
3. 选择明文攻击（Chosen-plaintext attack）：这种攻击中，敌手能够选择明文，并得到相应密文。试图确定其他密文对应的明文。
4. 选择密文攻击（Chosen-ciphertext attack）：最后一种攻击类型是敌手甚至可以选择密文并且得到相应的明文。敌手的目的依旧是确定其他密文的明文（其明文不能直接得到）。

### 1.3 古典加密术及其密码分析

密钥空间充分性原则（安全的必要条件，不是充分条件）：任何安全的加密方案必须拥有一个能够抵御穷举搜索的密钥空间。

**恺撒加密**：通过移动三个位置的字母进行加密。

**移位加密**：算法 $Gen()$ 输出一个在 $\{0, \cdots, 25\}$ 中的随机数 $k$；算法 $Enc()$ 使用密钥 $k$ 将英文字母组成的明文的每个字母向前移动 $k$ 个位置；算法 $Dec()$ 使用 $k$ 将密文的每个字母向后移动 $k$ 个位置。

移位加密密钥空间太小容易被穷举攻击

**单字母替换加密**：映射每个明文字符到一个不同的密文字符

密钥空间$26！$（约为$2^{88}$），但语言中单个字符的概率分布是已知的，文本越长，频率计算越接近平均值。

用 $0, \cdots, 25$ 表示英文字母。令$p_{i}$（$0 \le i \leq 25$）表示在普通英文文本中第$i$个字母的概率，对**已知的**$p_{i}$容易计算：任取两个字母，他们相等的概率为

$$
\sum_{i=0}^{25}p_{i}^{2} \approx 0.065
$$

**Vigenère(多字母移位)加密**：一个短的密码字被选作密钥，明文的加密是通过每个明文字符“加”每个密钥的字符（如同位移加密）。

### 1.4 现代密码学的基本原则

1. 解决任何密码学问题的第一步是公式化的表述严格且精确的安全定义。
2. 当密码学的构造方案的安全性依赖于某个未被证明的假设时，这种假设必须精确的陈述，并且，所假设的要尽可能的少。
3. 密码学构造方案应该伴随有严格的安全证明，跟随符合原则1的安全定义，以及与原则2陈述的假设有关（如果假设是需要的）。

## 第2章 完善保密加密

